#!/usr/bin/env bash

# k3d-manager - K3d Kubernetes cluster setup with Istio and storage configuration
#
# USAGE:
#   ./k3d-manager                    # Run default installation workflow
#   ./k3d-manager <function> [args]  # Run specific function
#
# FUNCTIONS:
#   install_colima                   # Install Colima container runtime (macOS)
#   install_docker                   # Install Docker CLI and configure it
#   install_k3d                      # Install K3d Kubernetes distribution
#   create_k3d_cluster <name>        # Create cluster with specified name
#   configure_k3d_cluster_istio      # Install Istio on the cluster
#   install_helm                     # Install Helm package manager
#   install_smb_csi_driver           # Install SMB CSI driver (Linux only)
#   create_nfs_share                 # Setup NFS export on host
#
# ISTIO TESTING:
#   test_istio                       # Istio functionality tests
#
# NFS DEBUGGING (for issue #1383 - github.com/k3d-io/k3d/issues/1383):
#   test_nfs_connectivity            # Test network connectivity to NFS
#   test_nfs_direct                  # Test direct NFS mounting
#
# Note: The above script functions list in NFS DEBUGGING section do not address K3d NFS mounting issues on macOS. The code leave here for the reference purpose only

# address symlink so that we can figure out where script is actually located
SOURCE="${BASH_SOURCE[0]}"
while [ -L "$SOURCE" ]; do
  DIR="$(cd -P "$(dirname "$SOURCE")" >/dev/null 2>&1 && pwd)"
  SOURCE="$(readlink "$SOURCE")"
  [[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE"
done
SCRIPT_DIR="$(cd -P "$(dirname "$SOURCE")" >/dev/null 2>&1 && pwd)"

# load our library functions
source "${SCRIPT_DIR}/system.sh"
source "${SCRIPT_DIR}/test.sh"

function create_k3d_cluster() {
   cluster_name=$1

   if _list_k3d_cluster | grep -q "$cluster_name"; then
      echo "Cluster $cluster_name already exists, skip"
      return 0
   fi

   yaml=$(mktemp -t k3d-XXXX.yaml)
    cat > "$yaml" <<EOF
apiVersion: k3d.io/v1alpha5
kind: Simple
metadata:
  name: $cluster_name
servers: 1
agents: 3
ports:
  - port: 8080:80
    nodeFilters: [loadbalancer]
  - port: 8443:443
    nodeFilters: [loadbalancer]
options:
  k3d:
    wait: true
  k3s:
    extraArgs:
      - arg: "--disable=traefik"
        nodeFilters: ["server:*"]
      - arg: "--disable=local-storage"
        nodeFilters: ["server:*"]
hostAliases:
  - ip: "$(_ip)"
    hostnames: ["host.k3d.internal"]
EOF

   _create_k3d_cluster "$yaml"

   trap 'cleanup_on_success "$yaml"' EXIT
}

function cleanup_on_success() {
   file_to_cleanup=$1
   echo "Cleaning up temporary files..."
   if [[ $? == 0 ]]; then
      rm -f "$file_to_cleanup"
   else
      echo "Error occurred, not cleaning up $file_to_cleanup"
   fi
}

function configure_k3d_cluster_istio() {
   cluster_name=$1

   install_kubernetes_cli
   install_istioctl
   _istioctl x precheck
   _istioctl install -y \
     --set profile=default \
     --set values.pilot.resources.requests.cpu=100m \
     --set values.pilot.resources.requests.memory=256Mi \
     --set values.global.proxy.resources.requests.cpu=50m \
     --set values.global.proxy.resources.requests.memory=64Mi \
     --set values.gateways.istio-ingressgateway.resources.requests.cpu=100m \
     --set values.gateways.istio-ingressgateway.resources.requests.memory=256Mi \
     --set values.gateways.istio-ingressgateway.type=LoadBalancer
   _kubectl label ns default istio-injection=enabled --overwrite
}

function install_smb_csi_driver() {
   if is_mac ; then
      echo "warning: SMB CSI driver is not supported on macOS"
      exit 0
   fi
   install_helm
   _helm repo add smb-csi-driver https://kubernetes-sigs.github.io/smb-csi-driver
   _helm repo update
   _helm upgrade --install smb-csi-driver smb-csi-driver/smb-csi-driver \
      --namespace kube-system

   if [[ $? != 0 ]]; then
      echo "Failed to install SMB CSI driver"
      exit 1
   fi
}

function create_nfs_share() {
   if grep -q "k3d-nfs" /etc/exports ; then
      echo "NFS share already exists, skip"
      return 0
   fi

   if is_mac ; then
      echo "Creating NFS share on macOS"
      mkdir -p $HOME/k3d-nfs
      if ! grep "$HOME/k3d-nfs" /etc/exports 2>&1 > /dev/null; then
         ip=$(ipconfig getifaddr en0)
         mask=$(ipconfig getoption en0 subnet_mask)
         prefix=$(python3 -c "import ipaddress; print(ipaddress.IPv4Network('0.0.0.0/$mask').prefixlen)")
         network=$(python3 -c "import ipaddress; print(ipaddress.IPv4Network('$ip/$prefix', strict=False).network_address)")
         export_line="/Users/$USER/k3d-nfs -alldirs -rw -insecure -mapall=$(id -u):$(id -g) -network $network -mask $mask"
         echo "$export_line" | \
            sudo tee -a /etc/exports
         sudo nfsd enable
         sudo nfsd restart  # Full restart instead of update
         showmount -e localhost
      fi
   fi
}

function configure_user_kubectl_access() {
   cluster_name="${1:-k3d-cluster}"

   echo "Configuring kubectl access for non-root user..."

   # Create kube directory in user's home if it doesn't exist
   mkdir -p $HOME/.kube

   # Get kubeconfig from k3d and save it to user's directory
   sudo k3d kubeconfig get "$cluster_name" > $HOME/.kube/config-"$cluster_name"

   # Set proper permissions
   chmod 600 $HOME/.kube/config-"$cluster_name"

   # Create/update the main config file
   if [ -f "$HOME/.kube/config" ]; then
      echo "Backing up existing kubeconfig to $HOME/.kube/config.bak"
      cp $HOME/.kube/config $HOME/.kube/config.bak
   fi

   cp $HOME/.kube/config-"$cluster_name" $HOME/.kube/config

   echo "kubectl is now configured for non-root access to $cluster_name"
   echo "You can verify with: kubectl get nodes"
   echo "If you have other clusters, you may want to merge configs using the KUBECONFIG environment variable"
}

function deploy_k3d_cluster() {
   cluster_name="${1:-k3d-cluster}"

   install_k3d
   create_k3d_cluster "$cluster_name"
   configure_k3d_cluster_istio "$cluster_name"
   configure_user_kubectl_access "$cluster_name"
   # install_smb_csi_driver
}

## -- main --
# Command line argument handling
if [[ $# -gt 0 ]]; then
    function_name=$1
    shift  # Remove the function name from the arguments

    if [[ "$(type -t $function_name)" == "function" ]]; then
        # Call the function with remaining arguments
        $function_name "$@"
    else
        echo "Error: Function '$function_name' not found"
        exit 1
    fi
fi

