#!/usr/bin/env bash

# k3d-manager - K3d Kubernetes cluster setup with Istio and storage configuration
#
# USAGE:
#   ./k3d-manager                    # Show usage and list core functions
#   ./k3d-manager <function> [args]  # Run specific function

# ensure we are running bash
if [[ -n "$BASH_VERSION" ]]; then
   echo "running under bash version ${BASH_VERSION}"
elif [[ -n "$ZSH_VERSION" ]]; then
   echo "running under zsh version ${ZSH_VERSION}"
fi

DEBUG=${DEBUG:-0}
if [[ $DEBUG -gt 0 ]]; then
      set -xv
fi

ENABLE_TRACE=${ENABLE_TRACE:-0}
if [[ $ENABLE_TRACE -gt 0 ]]; then
   export PS4='+ $(date "+%H:%M:%S") - pid=$$ ${BASH_SOURCE##*/}:${LINENO}:${FUNCNAME[0]}() '
   exec 19> /tmp/k3d.trace
   trap 'set +x 2>/dev/null; exec 19>&- 2>/dev/null || true' EXIT
   export BASH_XTRACEFD=19
   set -x
fi

# resolve symlink so that we can figure out where script is actually located
SOURCE="${BASH_SOURCE[0]}"
while [ -L "$SOURCE" ]; do
  DIR="$(cd -P "$(dirname "$SOURCE")" >/dev/null 2>&1 && pwd)"
  SOURCE="$(readlink "$SOURCE")"
  [[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE"
done
SCRIPT_DIR="$(cd -P "$(dirname "$SOURCE")" >/dev/null 2>&1 && pwd)"
PLUGINS_DIR="${SCRIPT_DIR}/plugins"

# load our library functions
source "${SCRIPT_DIR}/lib/system.sh"
source "${SCRIPT_DIR}/lib/cluster_provider.sh"
source "${SCRIPT_DIR}/lib/test.sh"
source "${SCRIPT_DIR}/lib/core.sh"

if [[ -n "${CLUSTER_PROVIDER:-}" ]]; then
    export K3D_MANAGER_PROVIDER="${K3D_MANAGER_PROVIDER:-$CLUSTER_PROVIDER}"
    export K3D_MANAGER_CLUSTER_PROVIDER="${K3D_MANAGER_CLUSTER_PROVIDER:-$CLUSTER_PROVIDER}"
    if declare -f _cluster_provider_set_active >/dev/null 2>&1; then
        _cluster_provider_set_active "$(printf '%s' "$CLUSTER_PROVIDER" | tr '[:upper:]' '[:lower:]')"
    fi
elif [[ -n "${K3D_MANAGER_PROVIDER:-}" ]]; then
    export CLUSTER_PROVIDER="$K3D_MANAGER_PROVIDER"
    export K3D_MANAGER_CLUSTER_PROVIDER="${K3D_MANAGER_CLUSTER_PROVIDER:-$K3D_MANAGER_PROVIDER}"
    if declare -f _cluster_provider_set_active >/dev/null 2>&1; then
        _cluster_provider_set_active "$(printf '%s' "$K3D_MANAGER_PROVIDER" | tr '[:upper:]' '[:lower:]')"
    fi
fi

function ___join_lines() {
    local separator="$1"
    shift || true

    local joined=""
    local token
    for token in "$@"; do
        if [[ -n "$joined" ]]; then
            joined+="$separator"
        fi
        joined+="$token"
    done

    printf '%s' "$joined"
}

function __discover_tests() {
    local tests_var="$1"
    local names_var="$2"
    local suites_var="${3:-}"

    eval "$tests_var=()"
    eval "$names_var=()"
    if [[ -n "$suites_var" ]]; then
        eval "$suites_var=()"
    fi

    local tests_root="${SCRIPT_DIR}/tests"
    if [[ ! -d "$tests_root" ]]; then
        return 0
    fi

    local -a search_dirs=("$tests_root")
    while IFS= read -r dir; do
        search_dirs+=("$dir")
    done < <(find "$tests_root" -mindepth 1 -maxdepth 1 -type d | sort)

    local tests_count=0
    local -a suite_labels=()
    local test_file
    local test_name
    local suite_name
    local seen
    while IFS= read -r test_file; do
        if [[ -z "$test_file" ]]; then
            continue
        fi
        eval "$tests_var+=(\"${test_file}\")"
        tests_count=$((tests_count + 1))
        test_name="$(basename "$test_file" .bats)"
        eval "$names_var+=(\"${test_name}\")"
        suite_name="$(basename "$(dirname "$test_file")")"
        if [[ "$suite_name" == "tests" ]]; then
            continue
        fi
        seen=0
        for dir in "${suite_labels[@]}"; do
            if [[ "$dir" == "$suite_name" ]]; then
                seen=1
                break
            fi
        done
        if [[ $seen -eq 0 ]]; then
            suite_labels+=("$suite_name")
        fi
    done < <(find "${search_dirs[@]}" -maxdepth 1 -type f -name '*.bats' | sort)

    if [[ -n "$suites_var" && $tests_count -gt 0 ]]; then
        eval "$suites_var+=(\"all\")"
        if [[ ${#suite_labels[@]} -gt 0 ]]; then
            while IFS= read -r suite_name; do
                eval "$suites_var+=(\"${suite_name}\")"
            done < <(printf '%s\n' "${suite_labels[@]}" | sort)
        fi
    fi

    return 0
}

function _usage() {
    local base_suites="all|lib|core|plugins"
    if [[ -n "${test_suites}" ]]; then
        test_suites="${base_suites}|${test_suites}"
    else
        test_suites="${base_suites}"
    fi

    local provider="${CLUSTER_PROVIDER:-$(_default_cluster_provider)}"

    local -a __tests=()
    local -a __test_names=()
    local -a __suite_names=()
    __discover_tests __tests __test_names __suite_names

    local provider="${CLUSTER_PROVIDER:-$(_default_cluster_provider)}"

    local test_synopsis="suite|test-name"
    if [[ ${#__suite_names[@]} -gt 0 || ${#__test_names[@]} -gt 0 ]]; then
        local -a synopsis_tokens=()
        if [[ ${#__suite_names[@]} -gt 0 ]]; then
            synopsis_tokens+=("${__suite_names[@]}")
        fi
        if [[ ${#__test_names[@]} -gt 0 ]]; then
            synopsis_tokens+=("${__test_names[@]}")
        fi
        local joined_synopsis="$( ___join_lines '|' "${synopsis_tokens[@]}" )"
        if [[ -n "$joined_synopsis" ]]; then
            test_synopsis="$joined_synopsis"
        fi
    fi

    local suites_summary=""
    if [[ ${#__suite_names[@]} -gt 0 ]]; then
        suites_summary="$( ___join_lines ', ' "${__suite_names[@]}" )"
    fi

    local tests_summary=""
    if [[ ${#__test_names[@]} -gt 0 ]]; then
        tests_summary="$( ___join_lines ', ' "${__test_names[@]}" )"
    fi

    cat <<EOF
Usage: ./k3d-manager <function> [args]

Available core functions:
$(declare -F | awk '{print $3}' | grep -v '^_' | sort | sed 's/^/  /')

Plugin functions are loaded on demand from scripts/plugins.

Cluster provider:
  Current: ${provider}
  Override by exporting CLUSTER_PROVIDER (macOS defaults to k3d).

Subcommands:
  test [options] ${test_suites}   Run BATS tests (see "test --help")
EOF
}

function __escape_regex_literal() {
    printf '%s' "$1" | sed -e 's/[].[^$*+?(){}|\\]/\\&/g' -e 's/\//\\\//g'
}

function __slugify() {
    local value="$1"
    local max_len="${2:-24}"
    if [[ -z "$value" ]]; then
        printf 'entry'
        return
    fi
    local sanitized
    sanitized=$(printf '%s' "$value" | tr '[:upper:]' '[:lower:]')
    sanitized=$(printf '%s' "$sanitized" | tr -c '[:alnum:]' '-')
    sanitized=$(printf '%s' "$sanitized" | sed -E 's/-+/-/g; s/^-//; s/-$//')
    if [[ -z "$sanitized" ]]; then
        sanitized='entry'
    fi
    if [[ ${#sanitized} -gt $max_len ]]; then
        sanitized="${sanitized:0:$max_len}"
        sanitized="${sanitized%-}"
        if [[ -z "$sanitized" ]]; then
            sanitized='entry'
        fi
    fi
    printf '%s' "$sanitized"
}

function __print_test_usage() {
    local -a __tests=()
    local -a __test_names=()
    local -a __suite_names=()
    __discover_tests __tests __test_names __suite_names

    local base_suites="all|lib|core|plugins"
    local suites_synopsis="$base_suites"
    if [[ ${#__suite_names[@]} -gt 0 ]]; then
        local -a extra_suites=()
        local suite_name
        for suite_name in "${__suite_names[@]}"; do
            case "$suite_name" in
                all|lib|core|plugins|tests)
                    continue
                    ;;
            esac
            extra_suites+=("$suite_name")
        done
        if [[ ${#extra_suites[@]} -gt 0 ]]; then
            suites_synopsis="${base_suites}|$( ___join_lines '|' "${extra_suites[@]}" )"
        fi
    fi

    local tests_summary="(none)"
    if [[ ${#__test_names[@]} -gt 0 ]]; then
        tests_summary="$( ___join_lines ', ' "${__test_names[@]}" )"
    fi

    cat <<EOF
Usage: test [-v|--verbose] [--case <name>] <suite|test|suite::case>

Run repository BATS tests. Suites may be one of: ${suites_synopsis}
Individual tests use the .bats filename without extension.

Options:
  -v, --verbose          Show output from passing tests
      --case <name>      Run a single test case (literal match)

Examples:
  test all
  test core
  test install_k3d
  test install_k3d --case "_install_k3d exports INSTALL_DIR"
  test install_k3d::"_install_k3d exports INSTALL_DIR"

Available tests: ${tests_summary}
EOF
}

function test() {
    local verbose=0
    local case_name=""
    local -a positional=()

    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                __print_test_usage
                return 0
                ;;
            -v|--verbose)
                verbose=1
                shift
                continue
                ;;
            --case)
                shift
                if [[ -z "${1:-}" ]]; then
                    echo "Missing value for --case." >&2
                    return 1
                fi
                case_name="$1"
                shift
                continue
                ;;
            --)
                shift
                positional+=("$@")
                break
                ;;
            -*)
                echo "Unknown option: $1" >&2
                return 1
                ;;
            *)
                positional+=("$1")
                shift
                continue
                ;;
        esac
    done

    if [[ ${#positional[@]} -eq 0 ]]; then
        __print_test_usage >&2
        return 1
    fi

    if [[ ${#positional[@]} -gt 1 ]]; then
        echo "Only one suite or test may be specified." >&2
        return 1
    fi

    local suite_spec="${positional[0]}"
    if [[ "$suite_spec" == *"::"* ]]; then
        local inline_case="${suite_spec#*::}"
        suite_spec="${suite_spec%%::*}"
        if [[ -z "$inline_case" ]]; then
            echo "Missing test case name in '${positional[0]}'." >&2
            return 1
        fi
        if [[ -z "$case_name" ]]; then
            case_name="$inline_case"
        fi
    fi

    _ensure_bats

    local tests_root="${SCRIPT_DIR}/tests"
    local -a search_dirs=("${tests_root}/lib" "${tests_root}/core" "${tests_root}/plugins")
    local -a tests=()
    while IFS= read -r test_file; do
        tests+=("$test_file")
    done < <(find "${search_dirs[@]}" -maxdepth 1 -type f -name '*.bats' | sort)

    local -a bats_args=()
    if (( verbose )); then
        bats_args+=(--show-output-of-passing-tests --print-output-on-failure)
    fi

    if [[ -n "$case_name" ]]; then
        local escaped_case
        escaped_case="$( __escape_regex_literal "$case_name" )"
        bats_args+=(--filter "^${escaped_case}$")
    fi

    local -a selected_tests=()

    if [[ "$suite_spec" == "all" ]]; then
        selected_tests=("${tests[@]}")
    elif [[ "$suite_spec" == "lib" || "$suite_spec" == "core" || "$suite_spec" == "plugins" ]]; then
        local dir="${tests_root}/${suite_spec}"
        while IFS= read -r test_file; do
            selected_tests+=("$test_file")
        done < <(find "$dir" -maxdepth 1 -type f -name '*.bats' | sort)
        if [[ ${#selected_tests[@]} -eq 0 ]]; then
            echo "No test suites found in '$suite_spec'." >&2
            return 1
        fi
    else
        local match_found=0
        local test_file
        for test_file in "${tests[@]}"; do
            local rel_with_ext
            rel_with_ext="${test_file#${tests_root}/}"
            local rel_without_ext
            rel_without_ext="${rel_with_ext%.bats}"
            local basename_no_ext
            basename_no_ext="${test_file##*/}"
            basename_no_ext="${basename_no_ext%.bats}"
            if [[ "$basename_no_ext" == "$suite_spec" \
               || "$rel_without_ext" == "$suite_spec" \
               || "$rel_with_ext" == "$suite_spec" \
               || "$test_file" == "$suite_spec" ]]; then
                selected_tests=("$test_file")
                match_found=1
                break
            fi
        done
        if [[ $match_found -eq 0 ]]; then
            echo "No test suite matching '$suite_spec'. Available suites:" >&2
            for test_file in "${tests[@]}"; do
                printf '  %s\n' "${test_file#${tests_root}/}" | sed 's/\.bats$//' >&2
            done
            return 1
        fi
    fi

    if [[ ${#selected_tests[@]} -eq 0 ]]; then
        echo "No test suites found." >&2
        return 1
    fi

    local repo_root
    repo_root="$(cd "${SCRIPT_DIR}/.." && pwd)"
    local log_root="${repo_root}/scratch/test-logs"
    local base_dir=""
    local artifacts_dir=""
    local log_file=""
    local ran_with_logging=0
    local status

    if mkdir -p "$log_root" 2>/dev/null; then
        local timestamp
        timestamp="$(date +%Y%m%d-%H%M%S)"
        local suite_slug
        suite_slug="$( __slugify "$suite_spec" 12 )"
        base_dir="${log_root}/${suite_slug}"
        if [[ -n "$case_name" ]]; then
            local case_slug
            case_slug="$( __slugify "$case_name" 6 )"
            if [[ -z "$case_slug" ]]; then
                case_slug='case'
            fi
            local case_hash
            case_hash=$(printf '%s' "$case_name" | sha256sum | cut -c1-4)
            base_dir+="/${case_slug}-${case_hash}"
        fi

        if mkdir -p "$base_dir" 2>/dev/null; then
            artifacts_dir="${base_dir}/${timestamp}"
            if mkdir -p "$artifacts_dir" 2>/dev/null; then
                bats_args+=(--gather-test-outputs-in "$artifacts_dir")
            else
                artifacts_dir=""
            fi

            log_file="${base_dir}/${timestamp}.log"
            if : > "$log_file" 2>/dev/null; then
                bats "${bats_args[@]}" "${selected_tests[@]}" 2>&1 | tee "$log_file"
                status=${PIPESTATUS[0]}
                ran_with_logging=1
            else
                log_file=""
            fi
        else
            base_dir=""
        fi
    fi

    if (( ran_with_logging == 0 )); then
        bats "${bats_args[@]}" "${selected_tests[@]}"
        status=$?
    fi

    if [[ $status -ne 0 ]]; then
        if [[ -n "$log_file" ]]; then
            local rel_log_file="$log_file"
            rel_log_file="${rel_log_file#${repo_root}/}"
            printf 'Test log saved to %s\n' "$rel_log_file" >&2
        else
            echo "Test log unavailable (failed to create log file)." >&2
        fi
        if [[ -n "$artifacts_dir" ]]; then
            local rel_artifacts_dir="$artifacts_dir"
            rel_artifacts_dir="${rel_artifacts_dir#${repo_root}/}"
            printf 'Collected artifacts in %s\n' "$rel_artifacts_dir" >&2
        fi
    else
        if [[ -n "$log_file" ]]; then
            rm -f "$log_file" 2>/dev/null || true
        fi
        if [[ -n "$artifacts_dir" ]]; then
            rm -rf "$artifacts_dir" 2>/dev/null || true
            local prune_dir="$artifacts_dir"
            while [[ "$prune_dir" != "$log_root" ]]; do
                prune_dir="$(dirname "$prune_dir")"
                rmdir "$prune_dir" 2>/dev/null || break
            done
        fi
    fi

    return $status
}

## -- main --
if [[ $# -eq 0 ]]; then
    _usage
    exit 0
fi

function_name=$1
shift  # Remove the function name from the arguments

if [[ "$(type -t "$function_name")" == "function" ]]; then
    # Call the function with remaining arguments
    $function_name "$@"
else
    _try_load_plugin "$function_name" "$@"
fi
